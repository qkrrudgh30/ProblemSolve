/*

숫자로 구성된 문자열 배열에서 특정 숫자 패턴의 발생을 찾으세요. 
그리드와 패턴 배열에서 각 문자열은 행을 나타냅니다.

패턴이 그리드에 존재하는 경우 "YES"를 반환하고, 존재하지 않으면 "NO"를 반환합니다.

함수 설명
    gridSearch 함수를 작성하세요. 이 함수는 다음 매개변수를 받습니다:
    vector<string> G: 탐색할 그리드 배열
    vector<string> P: 찾고자 하는 패턴 배열

반환값:
    패턴이 그리드에 존재하면 "YES"를, 존재하지 않으면 "NO"를 반환합니다.

입력 형식
    첫 번째 줄에 테스트 케이스의 수t가 주어집니다.

각 테스트 케이스는 다음과 같이 구성됩니다:
첫 번째 줄에 그리드의 행 R과 열 C가 주어집니다.
그 다음 R 줄에는 그리드 G의 각 행이 문자열로 주어집니다.
그 다음 줄에는 패턴의 행 r과 열 c가 주어집니다.
그 다음 r줄에는 패턴 P의 각 행이 문자열로 주어집니다.
제약 조건
    1≤t≤5
    1≤R,C≤1000
    1≤r,c≤100

각 문자열은 숫자로만 구성됩니다.

예제
    입력 예제 1
    2
    10 10
    7283455864
    6731158619
    8988242643
    3830589324
    2229505813
    5633845374
    6473530293
    7053106601
    0834282956
    4607924137
    3 4
    9505
    3845
    3530
    15 15
    400453592126560
    114213133098692
    474386082879648
    522356951189169
    887109450487496
    252802633388782
    502771484966748
    075975207693780
    511799789562806
    404007454272504
    549043809916080
    962410809534811
    445893523733475
    768705303214174
    650629270887160
    2 2
    99
    99
    출력 예제 1
    YES
    NO

*/

#pragma once

#include <string>
#include <vector>

using namespace std;

string gridSearch(vector<string> G, vector<string> P) {
    int GR = G.size(), GC = G[0].size();
    int PR = P.size(), PC = P[0].size();

    // 그리드의 각 위치에서 패턴이 시작하는지 확인
    for (int i = 0; i <= GR - PR; i++) 
    {
        for (int j = 0; j <= GC - PC; j++) 
        {
            bool bFound = true;

            // 현재 위치에서 패턴이 존재하는지 검사
            for (int x = 0; x < PR && bFound; x++) 
            {
                for (int y = 0; y < PC; y++) 
                {
                    if (G[i + x][j + y] != P[x][y]) 
                    {
                        bFound = false;
                        break;
                    }
                }
            }

            if (bFound == true) 
            {
                return "YES";
            }
        }
    }

    return "NO";
}